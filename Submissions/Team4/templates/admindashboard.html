<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Admin Dashboard - DecentraFlight</title>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/css/bootstrap.min.css" rel="stylesheet">
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" rel="stylesheet">
<!-- Add Web3.js -->
<script src="https://cdn.jsdelivr.net/npm/web3@1.8.0/dist/web3.min.js"></script>
<style>
body {
    background-color: #F5F8FA;
}

.home-content {
    margin-left: 260px;
    transition: margin-left 0.5s ease;
    width: calc(100% - 260px);
    box-sizing: border-box;
}

.index-list-header {
    display: flex;
    align-items: center;
    background: linear-gradient(to right, #1DA1F2, #0056b3);
    height: 15vh;
    width: 100%;
    box-sizing: border-box;
    color: white;
    padding: 20px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.index-list-content {
    background-color: #FFFFFF;
    height: auto;
    overflow-y: auto;
    padding: 20px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    border-radius: 8px;
}

.dashboard-stats {
    display: flex;
    justify-content: space-around;
    margin-bottom: 20px;
    flex-wrap: wrap;
}

.stat-box {
    background: #1DA1F2;
    color: white;
    padding: 15px;
    border-radius: 8px;
    text-align: center;
    width: 30%;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    margin-bottom: 15px;
}

.blockchain-stats {
    display: flex;
    justify-content: space-around;
    margin-top: 30px;
    margin-bottom: 30px;
    flex-wrap: wrap;
    background-color: #f8f9fa;
    padding: 20px;
    border-radius: 8px;
}

.blockchain-stat-box {
    background: #6c757d;
    color: white;
    padding: 15px;
    border-radius: 8px;
    text-align: center;
    width: 30%;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    margin-bottom: 15px;
}

table.table {
    background-color: white;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

table.table thead {
    background-color: #1DA1F2;
    color: white;
}

.sidebar.close ~ .home-content {
    margin-left: 78px;
    width: calc(100% - 78px);
}

.withdraw-section {
    background-color: #f8f9fa;
    border-radius: 8px;
    padding: 20px;
    margin-top: 30px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.withdraw-input {
    display: flex;
    align-items: center;
    margin-top: 15px;
    gap: 10px;
}

.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
}

.transaction-modal {
    background: white;
    padding: 30px;
    border-radius: 10px;
    max-width: 500px;
    width: 100%;
    text-align: center;
    box-shadow: 0 4px 20px rgba(0,0,0,0.1);
}

.transaction-status-icon {
    font-size: 4rem;
    margin-bottom: 20px;
}

.transaction-status-icon.pending {
    color: #FFC107;
    animation: pulse 1.5s infinite;
}

.transaction-status-icon.success {
    color: #28a745;
}

.transaction-status-icon.error {
    color: #dc3545;
}

.transaction-hash {
    background-color: #f8f9fa;
    border: 1px solid #e9ecef;
    border-radius: 8px;
    padding: 10px;
    margin-top: 20px;
    word-break: break-all;
    font-family: monospace;
}

.btn-close-modal {
    background-color: #1DA1F2;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 6px;
    cursor: pointer;
}

.section-title {
    display: flex;
    align-items: center;
    margin: 30px 0 15px 0;
    border-bottom: 2px solid #e9ecef;
    padding-bottom: 10px;
}

.section-title i {
    margin-right: 10px;
    color: #1DA1F2;
}

.config-card {
    background: #f8f9fa;
    border-radius: 8px;
    padding: 20px;
    margin-bottom: 20px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.config-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
    padding-bottom: 15px;
    border-bottom: 1px solid #e9ecef;
}

.config-item:last-child {
    border-bottom: none;
    margin-bottom: 0;
    padding-bottom: 0;
}

.config-input {
    display: flex;
    align-items: center;
    gap: 10px;
}

.action-btn {
    background-color: #1DA1F2;
    color: white;
    border: none;
    padding: 8px 15px;
    border-radius: 6px;
    cursor: pointer;
    transition: background-color 0.3s;
}

.action-btn:hover {
    background-color: #0d8bd9;
}

.action-btn:disabled {
    background-color: #ccc;
    cursor: not-allowed;
}

.nav-tabs .nav-link {
    border: none;
    color: #6c757d;
    font-weight: 500;
}

.nav-tabs .nav-link.active {
    color: #1DA1F2;
    background-color: transparent;
    border-bottom: 3px solid #1DA1F2;
}

.badge-delayed {
    background-color: #dc3545;
    color: white;
}

.badge-ontime {
    background-color: #28a745;
    color: white;
}

.badge-pending {
    background-color: #FFC107;
    color: #212529;
}

.badge-claimed {
    background-color: #6c757d;
    color: white;
}

.contract-metrics {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 15px;
    margin-top: 20px;
}

.metric-group {
    background: #f8f9fa;
    border-radius: 8px;
    padding: 15px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.metric-title {
    font-size: 0.9rem;
    font-weight: 500;
    color: #6c757d;
    margin-bottom: 5px;
}

.metric-value {
    font-size: 1.5rem;
    font-weight: 700;
    color: #212529;
}

.contract-address-bar {
    display: flex;
    align-items: center;
    background-color: #f8f9fa;
    padding: 10px 15px;
    border-radius: 8px;
    margin-bottom: 20px;
}

.contract-address-bar .address {
    font-family: monospace;
    margin: 0 10px;
    overflow: hidden;
    text-overflow: ellipsis;
}

.copy-btn {
    background: none;
    border: none;
    color: #1DA1F2;
    cursor: pointer;
}

.copy-btn:hover {
    color: #0d8bd9;
}

@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
}

@media (max-width: 992px) {
    .dashboard-stats {
        flex-wrap: wrap;
    }
    
    .stat-box {
        width: 45%;
    }
}

@media (max-width: 768px) {
    .home-content {
        margin-left: 0;
        width: 100%;
    }
    
    .stat-box {
        width: 100%;
    }
}

/* Pagination styles */
.pagination-container {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 20px;
    font-size: 0.9rem;
}

.pagination {
    margin-bottom: 0;
}

.page-select {
    display: flex;
    align-items: center;
}

.page-select select {
    margin: 0 10px;
}
</style>
</head>
<body>

{% include 'fragments/sidenav.html' %}

<section class="home-content">
    <div class="index-list-header">
        <h2><i class="fas fa-user-shield me-2"></i>Admin Dashboard</h2>
    </div>

    <div class="index-list-content">
        <!-- Connection Status & Contract Information -->
        <div class="alert alert-primary d-flex align-items-center" role="alert" id="connectionStatus">
            <i class="fas fa-plug me-2"></i>
            <div>
                Connecting to blockchain...
            </div>
        </div>

        <div class="contract-address-bar">
            <span><i class="fas fa-file-contract me-2"></i>Contract:</span>
            <span class="address" id="contractAddress">0x1159d7d7F1f55C8c31265a59Bb6A952917896C8E</span>
            <button class="copy-btn" onclick="copyToClipboard(document.getElementById('contractAddress').textContent)">
                <i class="fas fa-copy"></i>
            </button>
            <a href="#" target="_blank" id="explorerLink" class="ms-auto">
                <i class="fas fa-external-link-alt me-1"></i>View on Explorer
            </a>
        </div>

        <!-- Main Dashboard Stats -->
        <div class="dashboard-stats">
            <div class="stat-box">
                <h4>Total Policies</h4>
                <h2 id="totalPolicies">0</h2>
                <small>Total policies sold on the platform</small>
            </div>
            <div class="stat-box">
                <h4>Pool Funds</h4>
                <h2 id="insurancePoolFunds">0 MATIC</h2>
                <small>Funds allocated for policy payouts</small>
            </div>
            <div class="stat-box">
                <h4>Available to Withdraw</h4>
                <h2 id="withdrawableAmount">0 MATIC</h2>
                <small>Platform fees available to withdraw</small>
            </div>
        </div>

        <!-- Withdraw Section -->
        <div class="withdraw-section">
            <h3>Withdraw Excess Funds</h3>
            <p>As the admin, you can withdraw excess funds that are not part of the insurance pool.</p>
            
            <div class="withdraw-input">
                <input type="number" id="withdrawAmount" class="form-control" placeholder="Amount in MATIC" step="0.0001" min="0">
                <button class="btn btn-primary" onclick="withdrawFunds()">Withdraw</button>
            </div>
            <small class="text-muted">Note: You can only withdraw funds that are not allocated to active policies.</small>
            
            <!-- Max Button -->
            <div class="mt-3">
                <button class="btn btn-outline-secondary btn-sm" onclick="setMaxWithdrawal()">
                    <i class="fas fa-coins me-1"></i>Set Max Amount
                </button>
            </div>
        </div>

        <!-- Blockchain Stats -->
        <div class="blockchain-stats">
            <div class="blockchain-stat-box">
                <h5>Check Interval</h5>
                <div id="checkIntervalStat">60 minutes</div>
            </div>
            <div class="blockchain-stat-box">
                <h5>Recheck Interval</h5>
                <div id="recheckIntervalStat">30 minutes</div>
            </div>
            <div class="blockchain-stat-box">
                <h5>Min Delay for Payout</h5>
                <div id="minDelayStat">120 minutes</div>
            </div>
        </div>

        <!-- Contract Configuration Panel -->
        <div class="config-card">
            <h4>Contract Configuration</h4>
            <p>Adjust contract parameters for the policy lifecycle.</p>
            
            <div class="config-item">
                <div>
                    <h5>Check Interval</h5>
                    <p class="mb-0 text-muted">How often the contract checks flight statuses (in minutes)</p>
                </div>
                <div class="config-input">
                    <input type="number" id="checkIntervalInput" class="form-control" min="1">
                    <button class="action-btn" onclick="updateCheckInterval()">Update</button>
                </div>
            </div>
            
            <div class="config-item">
                <div>
                    <h5>Recheck Interval</h5>
                    <p class="mb-0 text-muted">How often a previously checked flight can be rechecked (in minutes)</p>
                </div>
                <div class="config-input">
                    <input type="number" id="recheckIntervalInput" class="form-control" min="5">
                    <button class="action-btn" onclick="updateRecheckInterval()">Update</button>
                </div>
            </div>
        </div>


        <!-- Policies Table with Pagination -->
        <h3 class="mt-4 mb-3">All Policies</h3>
        <div class="table-responsive">
            <div class="d-flex justify-content-end mb-2">
                <div class="page-select">
                    <label>Show entries: </label>
                    <select id="paginationSize" class="form-select form-select-sm" style="width: 70px;" onchange="changePageSize()">
                        <option value="5">5</option>
                        <option value="10" selected>10</option>
                        <option value="25">25</option>
                        <option value="50">50</option>
                    </select>
                </div>
            </div>
            
            <table class="table table-bordered">
                <thead>
                    <tr>
                        <th>Policy ID</th>
                        <th>Flight Number</th>
                        <th>Departure Date</th>
                        <th>Premium</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody id="policiesTableBody">
                    <tr>
                        <td colspan="5" class="text-center">Loading policies...</td>
                    </tr>
                </tbody>
            </table>
            
            <div class="pagination-container">
                <div>
                    Showing <span id="paginationStart">0</span> to <span id="paginationEnd">0</span> of <span id="paginationTotal">0</span> entries
                </div>
                <nav aria-label="Page navigation">
                    <ul class="pagination">
                        <li class="page-item disabled" id="paginationPrev">
                            <a class="page-link" href="#" aria-label="Previous" onclick="changePage('prev'); return false;">
                                <span aria-hidden="true">&laquo;</span>
                            </a>
                        </li>
                        <li class="page-item active"><a class="page-link" href="#" onclick="changePage(1); return false;">1</a></li>
                        <li class="page-item disabled" id="paginationNext">
                            <a class="page-link" href="#" aria-label="Next" onclick="changePage('next'); return false;">
                                <span aria-hidden="true">&raquo;</span>
                            </a>
                        </li>
                    </ul>
                </nav>
            </div>
        </div>
    </div>
</section>

<!-- Policy Details Modal -->
<div class="modal fade" id="policyModal" tabindex="-1" aria-labelledby="policyModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="policyModalLabel">Policy Details</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body" id="policyModalBody">
                Loading...
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                <button type="button" class="btn btn-warning" id="forceRecheckBtn">
                    <i class="fas fa-sync-alt me-1"></i>Force Recheck
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Bootstrap 5 JS -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/js/bootstrap.bundle.min.js"></script>
<!-- Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>

(function checkAuth() {
    fetch('/check_auth', {
        method: 'GET',
        credentials: 'include'
    })
    .then(response => {
        if (!response.ok) {
            window.location.href = "/401";
        }
    })
    .catch(() => {
        window.location.href = "/401";
    });
})();

// Contract configuration
const CONTRACT_ADDRESS = "0x1159d7d7F1f55C8c31265a59Bb6A952917896C8E";
const ADMIN_WALLET = "0xF51EE95f3cEA7D1f474fE678720D3E126FED364B";

// Global variables
let web3Instance;
let contractInstance;
let currentAccount;

// Pagination variables
let policyData = []; // Store all policies
let currentPage = 1;
let pageSize = 10;
let totalPages = 1;

// Enhanced ABI with all the functions we need to access
const CONTRACT_ABI = [
    // View functions
    {
        "inputs": [],
        "name": "totalPoolFunds",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "totalPolicies",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "totalRevenueFunds",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "totalClaimedFunds",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "getAvailableRevenue",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "recheckInterval",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "checkInterval",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [{"internalType": "bytes32", "name": "policyId", "type": "bytes32"}],
        "name": "getPolicyDetails",
        "outputs": [
            {"internalType": "address", "name": "policyholder", "type": "address"},
            {"internalType": "string", "name": "flightIata", "type": "string"},
            {"internalType": "uint256", "name": "premium", "type": "uint256"},
            {"internalType": "uint256", "name": "flightDate", "type": "uint256"},
            {"internalType": "uint256", "name": "lastChecked", "type": "uint256"},
            {"internalType": "uint256", "name": "delayMinutes", "type": "uint256"},
            {"internalType": "uint8", "name": "status", "type": "uint8"}
        ],
        "stateMutability": "view",
        "type": "function"
    },
    // Write functions
    {
        "inputs": [{"internalType": "uint256", "name": "amount", "type": "uint256"}],
        "name": "withdrawExcessFunds",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [{"internalType": "bytes32", "name": "policyId", "type": "bytes32"}],
        "name": "forceRecheck",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [{"internalType": "uint256", "name": "newInterval", "type": "uint256"}],
        "name": "setCheckInterval",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [{"internalType": "uint256", "name": "newInterval", "type": "uint256"}],
        "name": "setRecheckInterval",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    }
];

// Helper function to format MATIC with 4 decimals
function formatMatic(wei) {
    if (!web3Instance) return "0";
    return parseFloat(web3Instance.utils.fromWei(wei, 'ether')).toFixed(4);
}

// Helper function to convert timestamp to date string
function formatTimestamp(timestamp) {
    if (!timestamp || timestamp == 0) return 'Never';
    const date = new Date(timestamp * 1000);
    return date.toLocaleString();
}

// Helper function to correctly format policy ID for blockchain
function formatPolicyId(policyId) {
    // Check if policyId is valid
    if (!policyId || typeof policyId !== 'string') {
        console.error("Invalid policy ID:", policyId);
        return null;
    }
    
    // Remove '0x' prefix if it exists
    const policyIdClean = policyId.startsWith('0x') ? policyId.slice(2) : policyId;
    
    // Ensure it's padded to the right length (32 bytes = 64 hex chars)
    // Only pad if the length is less than 64 chars
    if (policyIdClean.length > 64) {
        console.warn("Policy ID is longer than expected:", policyIdClean);
        return '0x' + policyIdClean.slice(0, 64); // Truncate if too long
    }
    
    return '0x' + policyIdClean.padStart(64, '0');
}

// Function to show transaction status modals
function showTransactionStatus(status, txHash = '', options = {}) {
    // Remove any existing modals first
    const existingModals = document.querySelectorAll('.modal-overlay');
    existingModals.forEach(modal => modal.remove());

    // Create the modal dynamically
    const modalOverlay = document.createElement('div');
    modalOverlay.className = 'modal-overlay';
    
    // Custom message support
    const customMessage = options.message || null;
    
    const modalContent = `
        <div class="transaction-modal">
            <div class="transaction-status-icon ${status}">
                ${status === 'pending' ? '<i class="fas fa-spinner fa-spin"></i>' : 
                  status === 'success' ? '<i class="fas fa-check-circle"></i>' : 
                  '<i class="fas fa-exclamation-circle"></i>'}
            </div>
            <h3>${
                status === 'pending' ? 'Transaction Processing' : 
                status === 'success' ? 'Transaction Successful' : 
                'Transaction Failed'
            }</h3>
            <p>${
                customMessage || 
                (status === 'pending' ? 'Your transaction is being processed on the blockchain. This may take a few moments.' : 
                status === 'success' ? 'Your transaction has been confirmed on the blockchain.' : 
                'There was an issue processing your transaction. Please try again.')
            }</p>
            ${txHash ? `<div class="transaction-hash">${txHash}</div>` : ''}
            <button class="btn-close-modal mt-3">Close</button>
        </div>
    `;
    
    modalOverlay.innerHTML = modalContent;
    
    // Add close functionality
    const closeButton = modalOverlay.querySelector('.btn-close-modal');
    closeButton.addEventListener('click', () => {
        document.body.removeChild(modalOverlay);
    });
    
    // Optional: Auto-close after 5 seconds for non-error statuses
    if (status !== 'error') {
        setTimeout(() => {
            if (document.body.contains(modalOverlay)) {
                document.body.removeChild(modalOverlay);
            }
        }, 5000);
    }
    
    // Add to body
    document.body.appendChild(modalOverlay);

    return modalOverlay;
}

// Copy to clipboard function
function copyToClipboard(text) {
    navigator.clipboard.writeText(text).then(() => {
        // Alert the user that the text was copied
        alert('Copied to clipboard!');
    }).catch(err => {
        console.error('Failed to copy:', err);
    });
}

// Direct Web3 call to get contract data 
async function getContractDataDirectly() {
    try {
        console.log("Getting contract data directly via Web3...");
        if (!web3Instance || !contractInstance) {
            console.error("Web3 or contract instance not initialized");
            return;
        }
        
        // Get contract balance directly
        const balance = await web3Instance.eth.getBalance(CONTRACT_ADDRESS);
        const balanceInMatic = web3Instance.utils.fromWei(balance, 'ether');
        console.log("Direct contract balance:", balance, "wei =", balanceInMatic, "MATIC");
        
        // Get pool funds directly
        try {
            const poolFunds = await contractInstance.methods.totalPoolFunds().call();
            const poolFundsInMatic = web3Instance.utils.fromWei(poolFunds, 'ether');
            console.log("Direct pool funds:", poolFunds, "wei =", poolFundsInMatic, "MATIC");
            
            // Update UI with insurance pool funds - directly update UI
            const insurancePoolEl = document.getElementById("insurancePoolFunds");
            if (insurancePoolEl) {
                insurancePoolEl.innerText = parseFloat(poolFundsInMatic).toFixed(6) + " MATIC";
            }
            
            // Get available revenue directly from contract
            const revenueFunds = await contractInstance.methods.totalRevenueFunds().call();
            const revenueFundsInMatic = web3Instance.utils.fromWei(revenueFunds, 'ether');
            console.log("Direct revenue funds:", revenueFunds, "wei =", revenueFundsInMatic, "MATIC");
            
            // Update UI with withdrawable amount (which is now the revenue)
            const withdrawableEl = document.getElementById("withdrawableAmount");
            if (withdrawableEl) {
                withdrawableEl.innerText = parseFloat(revenueFundsInMatic).toFixed(6) + " MATIC";
            }
            
            // Store for later use
            window.withdrawableAmount = parseFloat(revenueFundsInMatic);
            
            // Still update the other blockchain stats
            const checkInterval = await contractInstance.methods.checkInterval().call();
            const recheckInterval = await contractInstance.methods.recheckInterval().call();
            
            // Convert to minutes
            const checkIntervalMinutes = Math.floor(checkInterval / 60);
            const recheckIntervalMinutes = Math.floor(recheckInterval / 60);
            
            // Update UI for intervals
            document.getElementById("checkIntervalStat").innerText = checkIntervalMinutes + " minutes";
            document.getElementById("recheckIntervalStat").innerText = recheckIntervalMinutes + " minutes";
            document.getElementById("checkIntervalInput").value = checkIntervalMinutes;
            document.getElementById("recheckIntervalInput").value = recheckIntervalMinutes;
            document.getElementById("minDelayStat").innerText = "120 minutes";
            
        } catch (error) {
            console.error("Error getting contract data directly:", error);
        }
    } catch (error) {
        console.error("Error getting direct contract data:", error);
    }
}

// Load contract funds from backend API 
async function loadContractFunds() {
    try {
        console.log("Fetching contract funds from backend...");
        const response = await fetch("/contract_funds");
        
        if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
        }
        
        const data = await response.json();
        
        if (data.status === "error") {
            console.error("Error from API:", data.error);
            // Fall back to direct Web3 call if API fails
            await getContractDataDirectly();
            return;
        }
        
        console.log("Contract funds data received:", data);
        
        // Update UI with insurance pool funds
        const insurancePoolEl = document.getElementById("insurancePoolFunds");
        if (insurancePoolEl && (data.pool_funds > 0 || !window.directDataLoaded)) {
            insurancePoolEl.innerText = parseFloat(data.pool_funds).toFixed(6) + " MATIC";
        }
        
        // Update UI with withdrawable amount
        const withdrawableEl = document.getElementById("withdrawableAmount");
        if (withdrawableEl && (data.withdrawable >= 0 || !window.directDataLoaded)) {
            withdrawableEl.innerText = parseFloat(data.withdrawable).toFixed(6) + " MATIC";
        }
        
        // Store withdrawable amount as a global variable for later use
        window.withdrawableAmount = data.withdrawable;
        console.log("Withdrawable amount set to:", window.withdrawableAmount);
        
    } catch (error) {
        console.error("Error fetching contract funds:", error);
        // Fall back to direct Web3 call if API fails
        await getContractDataDirectly();
    }
}

// Simplified version of loadContractData that follows the second code's approach
async function loadContractData() {
    try {
        if (!web3Instance || !contractInstance) {
            console.error("Web3 or contract not initialized");
            return;
        }
        
        // Double approach: try direct Web3 calls first, then load from API
        window.directDataLoaded = false;
        
        // Try both methods for getting data
        await Promise.all([
            getContractDataDirectly(),  // Direct Web3 call
            loadContractFunds(),        // API call
            loadPoliciesFromBackend()   // Load policies
        ]);
        
        // Then load remaining blockchain data (policies count, etc)
        await loadBlockchainData();
        
    } catch (error) {
        console.error("Error loading contract data:", error);
    }
}

// Set max withdrawal amount
function setMaxWithdrawal() {
    const withdrawInput = document.getElementById("withdrawAmount");
    if (window.withdrawableAmount) {
        withdrawInput.value = window.withdrawableAmount;
    } else {
        alert("Withdrawable amount not yet loaded. Please wait.");
    }
}

// Load all contract data
function updateUIWithContractData() {
    if (window.contractPoolFunds !== undefined) {
        const insurancePoolEl = document.getElementById("insurancePoolFunds");
        if (insurancePoolEl) {
            insurancePoolEl.innerText = parseFloat(window.contractPoolFunds).toFixed(6) + " MATIC";
        }
    }
    
    if (window.contractRevenueFunds !== undefined) {
        const withdrawableEl = document.getElementById("withdrawableAmount");
        if (withdrawableEl) {
            withdrawableEl.innerText = parseFloat(window.contractRevenueFunds).toFixed(6) + " MATIC";
        }
        window.withdrawableAmount = window.contractRevenueFunds;
    }
}


// Load blockchain data 
async function loadBlockchainData() {
    try {
        const accounts = await web3Instance.eth.getAccounts();
        currentAccount = accounts[0];
        
        // Check if admin
        if (currentAccount.toLowerCase() !== ADMIN_WALLET.toLowerCase()) {
            console.warn("Connected account is not admin");
            const withdrawSection = document.querySelector('.withdraw-section');
            if (withdrawSection) {
                withdrawSection.innerHTML = "<p class='text-danger'>You are not connected with the admin wallet. Please connect with the admin wallet to enable withdrawals.</p>";
            }
        } else {
            // Update connection status for admin
            const connectionStatus = document.getElementById("connectionStatus");
            if (connectionStatus) {
                connectionStatus.className = "alert alert-success d-flex align-items-center";
                connectionStatus.innerHTML = `
                    <i class="fas fa-plug me-2"></i>
                    <div>
                        Connected as admin: ${currentAccount.substring(0, 6)}...${currentAccount.substring(38)}
                    </div>
                `;
            }
            
            // Set explorer link
            const explorerLink = document.getElementById("explorerLink");
            if (explorerLink) {
                explorerLink.href = `https://mumbai.polygonscan.com/address/${CONTRACT_ADDRESS}`;
            }
        }

        // Get total policies
        try {
            const onchainPolicies = await contractInstance.methods.totalPolicies().call();
            const totalPoliciesEl = document.getElementById("totalPolicies");
            if (totalPoliciesEl) {
                totalPoliciesEl.innerText = onchainPolicies;
            }
            console.log("Policies on blockchain:", onchainPolicies);
        } catch (error) {
            console.error("Error getting total policies:", error);
        }
        
        // Try getting contract data directly after backend call
        window.directDataLoaded = true;
        await getContractDataDirectly();

    } catch (error) {
        console.error("Error loading blockchain data:", error);
        
        // Update connection status to show error
        const connectionStatus = document.getElementById("connectionStatus");
        if (connectionStatus) {
            connectionStatus.className = "alert alert-danger d-flex align-items-center";
            connectionStatus.innerHTML = `
                <i class="fas fa-exclamation-triangle me-2"></i>
                <div>
                    Error connecting to blockchain: ${error.message}
                </div>
            `;
        }
    }
}

// Load policies from the backend with pagination
async function loadPoliciesFromBackend() {
    try {
        let response = await fetch("/admin_stats");
        let data = await response.json();

        if (!data.policies || data.policies.length === 0) {
            document.getElementById("policiesTableBody").innerHTML = `
                <tr>
                    <td colspan="5" class="text-center">No policies found</td>
                </tr>
            `;
            // Update pagination info
            updatePaginationInfo(0, 0, 0);
            return;
        }
        
        // Store all policies in the global array
        policyData = data.policies.map(policy => {
            // Map backend status to our enum
            let statusBadge;
            let statusClass;
            
            switch(policy.status ? policy.status.toLowerCase() : 'unknown') {
                case 'pending':
                    statusBadge = 'Pending';
                    statusClass = 'badge-pending';
                    break;
                case 'on time':
                case 'ontime':
                    statusBadge = 'On Time';
                    statusClass = 'badge-ontime';
                    break;
                case 'delayed':
                    statusBadge = 'Delayed';
                    statusClass = 'badge-delayed';
                    break;
                case 'claimed':
                case 'compensated':
                    statusBadge = 'Claimed';
                    statusClass = 'badge-claimed';
                    break;
                default:
                    statusBadge = policy.status || 'Unknown';
                    statusClass = '';
            }
            
            return {
                ...policy,
                statusBadge,
                statusClass
            };
        });
        
        // Calculate total pages based on pageSize
        totalPages = Math.ceil(policyData.length / pageSize);
        
        // Render the first page
        renderPoliciesPage(1);
        
        // Update pagination UI
        updatePagination();

    } catch (error) {
        console.error("Error fetching policies:", error);
        document.getElementById("policiesTableBody").innerHTML = `
            <tr>
                <td colspan="5" class="text-center">Error loading policies</td>
            </tr>
        `;
        // Update pagination info
        updatePaginationInfo(0, 0, 0);
    }
}

// Render a specific page of policies
function renderPoliciesPage(page) {
    if (!policyData || policyData.length === 0) {
        document.getElementById("policiesTableBody").innerHTML = `
            <tr>
                <td colspan="5" class="text-center">No policies found</td>
            </tr>
        `;
        return;
    }
    
    // Calculate which policies to show
    const startIndex = (page - 1) * pageSize;
    const endIndex = Math.min(startIndex + pageSize, policyData.length);
    const policiesToShow = policyData.slice(startIndex, endIndex);
    
    // Generate the table rows
    let policyRows = '';
    
    policiesToShow.forEach(policy => {
        policyRows += `<tr>
            <td><small>${policy.id}</small></td>
            <td>${policy.flight_id || policy.flight_number || "N/A"}</td>
            <td>${policy.departure_date || "N/A"}</td>
            <td>${policy.premium}</td>
            <td><span class="badge bg-secondary ${policy.statusClass}">${policy.statusBadge}</span></td>
        </tr>`;
    });
    
    document.getElementById("policiesTableBody").innerHTML = policyRows;
    
    // Update the pagination info
    updatePaginationInfo(startIndex + 1, endIndex, policyData.length);
    
    // Update current page
    currentPage = page;
}

// Update pagination UI
function updatePagination() {
    const paginationElement = document.querySelector('.pagination');
    
    if (!paginationElement) return;
    
    // Clear existing pagination links except first and last
    const firstItem = paginationElement.querySelector('li:first-child');
    const lastItem = paginationElement.querySelector('li:last-child');
    
    paginationElement.innerHTML = '';
    paginationElement.appendChild(firstItem);
    
    // Update prev button state
    firstItem.classList.toggle('disabled', currentPage === 1);
    
    // Generate page numbers
    const maxVisiblePages = 5;
    let startPage = Math.max(1, currentPage - Math.floor(maxVisiblePages / 2));
    let endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);
    
    // Adjust if we're near the end
    if (endPage - startPage + 1 < maxVisiblePages && startPage > 1) {
        startPage = Math.max(1, endPage - maxVisiblePages + 1);
    }
    
    // Add page numbers
    for (let i = startPage; i <= endPage; i++) {
        const pageItem = document.createElement('li');
        pageItem.className = `page-item ${i === currentPage ? 'active' : ''}`;
        
        const pageLink = document.createElement('a');
        pageLink.className = 'page-link';
        pageLink.href = '#';
        pageLink.textContent = i;
        pageLink.onclick = function(e) {
            e.preventDefault();
            changePage(i);
        };
        
        pageItem.appendChild(pageLink);
        paginationElement.appendChild(pageItem);
    }
    
    paginationElement.appendChild(lastItem);
    
    // Update next button state
    lastItem.classList.toggle('disabled', currentPage === totalPages || totalPages === 0);
}

// Change page
function changePage(page) {
    if (page === 'prev') {
        if (currentPage > 1) {
            renderPoliciesPage(currentPage - 1);
            updatePagination();
        }
    } else if (page === 'next') {
        if (currentPage < totalPages) {
            renderPoliciesPage(currentPage + 1);
            updatePagination();
        }
    } else {
        renderPoliciesPage(page);
        updatePagination();
    }
}

// Change page size
function changePageSize() {
    const newPageSize = parseInt(document.getElementById('paginationSize').value);
    pageSize = newPageSize;
    totalPages = Math.ceil(policyData.length / pageSize);
    
    // Reset to first page
    renderPoliciesPage(1);
    updatePagination();
}

// Update pagination info text
function updatePaginationInfo(start, end, total) {
    document.getElementById('paginationStart').textContent = start;
    document.getElementById('paginationEnd').textContent = end;
    document.getElementById('paginationTotal').textContent = total;
}

// View policy details
async function viewPolicyDetails(policyId) {
    try {
        const policyModal = new bootstrap.Modal(document.getElementById('policyModal'));
        document.getElementById('policyModalBody').innerHTML = 'Loading policy details...';
        policyModal.show();
        
        if (!web3Instance || !contractInstance) {
            document.getElementById('policyModalBody').innerHTML = 'Contract not initialized. Please connect to blockchain.';
            return;
        }
        
        // Ensure the policyId is correctly formatted
        let formattedPolicyId = formatPolicyId(policyId);
        if (!formattedPolicyId) {
            document.getElementById('policyModalBody').innerHTML = `
                <div class="alert alert-danger">
                    <p>Invalid policy ID format: ${policyId}</p>
                    <p>Policy IDs should be in format: 0x... or without 0x prefix</p>
                </div>
            `;
            return;
        }
        
        console.log("Formatted policy ID:", formattedPolicyId);
        
        try {
            // Get policy details from blockchain
            const [
                policyholder,
                flightIata,
                premium,
                flightDate,
                lastChecked,
                delayMinutes,
                status
            ] = await contractInstance.methods.getPolicyDetails(formattedPolicyId).call();
            
            // Map status enum to text
            const statusText = ['Pending', 'On Time', 'Delayed', 'Claimed'][Number(status)];
            const statusClass = ['badge-pending', 'badge-ontime', 'badge-delayed', 'badge-claimed'][Number(status)];
            
            // Calculate payout amount
            const payoutAmount = (Number(premium) * 3); // 300% payout
            
            // Format the details HTML
            const detailsHtml = `
                <div class="row">
                    <div class="col-md-6">
                        <h6>Policy ID</h6>
                        <p><code>${policyId}</code></p>
                        
                        <h6>Policyholder</h6>
                        <p><code>${policyholder}</code></p>
                        
                        <h6>Flight Number</h6>
                        <p>${flightIata}</p>
                        
                        <h6>Flight Date</h6>
                        <p>${formatTimestamp(flightDate)}</p>
                    </div>
                    <div class="col-md-6">
                        <h6>Premium</h6>
                        <p>${formatMatic(premium)} MATIC</p>
                        
                        <h6>Potential Payout</h6>
                        <p>${formatMatic(payoutAmount.toString())} MATIC</p>
                        
                        <h6>Status</h6>
                        <p><span class="badge bg-secondary ${statusClass}">${statusText}</span></p>
                        
                        <h6>Delay Minutes</h6>
                        <p>${delayMinutes > 0 ? delayMinutes + ' minutes' : 'No delay detected'}</p>
                    </div>
                </div>
                <div class="row mt-3">
                    <div class="col-12">
                        <h6>Last Checked</h6>
                        <p>${formatTimestamp(lastChecked)}</p>
                    </div>
                </div>
            `;
            
            document.getElementById('policyModalBody').innerHTML = detailsHtml;
            
            // Configure the force recheck button
            const forceRecheckBtn = document.getElementById('forceRecheckBtn');
            
            // Only show for admin and if not claimed
            if (currentAccount && currentAccount.toLowerCase() === ADMIN_WALLET.toLowerCase() && Number(status) !== 3) {
                forceRecheckBtn.style.display = 'block';
                forceRecheckBtn.onclick = () => forceRecheckPolicy(formattedPolicyId);
            } else {
                forceRecheckBtn.style.display = 'none';
            }
            
        } catch (error) {
            console.error("Error fetching policy details:", error);
            
            // Try to get policy from backend as fallback
            try {
                const response = await fetch(`/policy_details?policy_id=${encodeURIComponent(policyId)}`);
                if (response.ok) {
                    const policyData = await response.json();
                    
                    if (policyData.error) {
                        throw new Error(policyData.error);
                    }
                    
                    // Format the details HTML for backend data
                    const detailsHtml = `
                        <div class="row">
                            <div class="col-md-6">
                                <h6>Policy ID</h6>
                                <p><code>${policyData.id || policyId}</code></p>
                                
                                <h6>Blockchain Policy ID</h6>
                                <p><code>${policyData.blockchain_policy_id || "Not set"}</code></p>
                                
                                <h6>Flight Number</h6>
                                <p>${policyData.flight_id || "Unknown"}</p>
                                
                                <h6>Departure Date</h6>
                                <p>${policyData.departure_date || "Unknown"}</p>
                            </div>
                            <div class="col-md-6">
                                <h6>Premium</h6>
                                <p>${policyData.premium || "Unknown"}</p>
                                
                                <h6>Status</h6>
                                <p><span class="badge bg-secondary">${policyData.status || "Unknown"}</span></p>
                                
                                <h6>Wallet Address</h6>
                                <p><code>${policyData.wallet_address || "Unknown"}</code></p>
                            </div>
                        </div>
                    `;
                    
                    document.getElementById('policyModalBody').innerHTML = detailsHtml;
                    
                    // Configure the force recheck button - show only if not compensated
                    const forceRecheckBtn = document.getElementById('forceRecheckBtn');
                    
                    if (currentAccount && currentAccount.toLowerCase() === ADMIN_WALLET.toLowerCase() && 
                        policyData.status !== 'COMPENSATED' && policyData.blockchain_policy_id) {
                        forceRecheckBtn.style.display = 'block';
                        forceRecheckBtn.onclick = () => forceRecheckPolicy(policyData.blockchain_policy_id);
                    } else {
                        forceRecheckBtn.style.display = 'none';
                    }
                } else {
                    throw new Error("Failed to fetch policy from backend");
                }
            } catch (backendError) {
                console.error("Backend fallback also failed:", backendError);
                document.getElementById('policyModalBody').innerHTML = `
                    <div class="alert alert-danger">
                        <p>Error fetching policy details from blockchain: ${error.message}</p>
                        <p>Also failed to fetch from backend: ${backendError.message}</p>
                        <p>Please make sure you've entered a valid policy ID.</p>
                        <p>Policy IDs should be in format: 0x... or without 0x prefix</p>
                    </div>
                `;
            }
        }
        
    } catch (error) {
        console.error("Error in viewPolicyDetails:", error);
        document.getElementById('policyModalBody').innerHTML = `
            <div class="alert alert-danger">
                <p>Error processing policy details: ${error.message}</p>
                <p>Please try again or contact support.</p>
            </div>
        `;
    }
}

// Check policy details by ID
async function checkPolicyDetails() {
    const policyIdInput = document.getElementById('policyIdInput').value.trim();
    if (!policyIdInput) {
        alert('Please enter a valid Policy ID');
        return;
    }
    
    try {
        viewPolicyDetails(policyIdInput);
    } catch (error) {
        console.error("Error checking policy:", error);
        alert('Error checking policy: ' + error.message);
    }
}

// Force recheck a policy
async function forceRecheckPolicy(policyId) {
    // If policyId is not provided, get it from the input
    if (!policyId) {
        policyId = document.getElementById('policyIdInput').value.trim();
        if (!policyId) {
            alert('Please enter a valid Policy ID');
            return;
        }
    }
    
    try {
        if (!contractInstance || !currentAccount) {
            alert('Web3 not initialized or not connected');
            return;
        }
        
        if (currentAccount.toLowerCase() !== ADMIN_WALLET.toLowerCase()) {
            alert('Only admin can force recheck policies');
            return;
        }
        
        // Format policyId for blockchain
        const formattedPolicyId = formatPolicyId(policyId);
        if (!formattedPolicyId) {
            alert('Invalid policy ID format');
            return;
        }
        
        // Show pending transaction modal
        const modal = showTransactionStatus('pending', '', {
            message: 'Processing force recheck transaction. Please wait...'
        });
        
        // Call the force recheck function
        const tx = await contractInstance.methods.forceRecheck(formattedPolicyId).send({
            from: currentAccount,
            gas: 300000,
            gasPrice: web3Instance.utils.toWei('50', 'gwei')
        });
        
        console.log("Force recheck transaction:", tx);
        
        // Show success
        showTransactionStatus('success', tx.transactionHash, {
            message: 'Force recheck transaction successful! The policy will be rechecked for delays.'
        });
        
        // Close the policy modal if it's open
        const policyModal = bootstrap.Modal.getInstance(document.getElementById('policyModal'));
        if (policyModal) {
            policyModal.hide();
        }
        
        // Refresh data after a short delay
        setTimeout(() => {
            loadPoliciesFromBackend();
        }, 3000);
        
    } catch (error) {
        console.error("Error forcing policy recheck:", error);
        showTransactionStatus('error', '', {
            message: 'Error forcing policy recheck: ' + error.message
        });
    }
}

// Update check interval
async function updateCheckInterval() {
    try {
        if (!contractInstance || !currentAccount) {
            alert('Web3 not initialized or not connected');
            return;
        }
        
        if (currentAccount.toLowerCase() !== ADMIN_WALLET.toLowerCase()) {
            alert('Only admin can update intervals');
            return;
        }
        
        const intervalInput = document.getElementById('checkIntervalInput');
        const intervalMinutes = parseInt(intervalInput.value);
        
        if (isNaN(intervalMinutes) || intervalMinutes < 1) {
            alert('Please enter a valid interval (minimum 1 minute)');
            return;
        }
        
        // Convert minutes to seconds for the contract
        const intervalSeconds = intervalMinutes * 60;
        
        // Show pending transaction modal
        showTransactionStatus('pending', '', {
            message: 'Processing update check interval transaction. Please wait...'
        });
        
        // Call the set check interval function
        const tx = await contractInstance.methods.setCheckInterval(intervalSeconds).send({
            from: currentAccount,
            gas: 200000,
            gasPrice: web3Instance.utils.toWei('50', 'gwei')
        });
        
        console.log("Update check interval transaction:", tx);
        
        // Show success
        showTransactionStatus('success', tx.transactionHash, {
            message: 'Check interval updated successfully to ' + intervalMinutes + ' minutes!'
        });
        
        // Update UI
        document.getElementById('checkIntervalStat').innerText = intervalMinutes + ' minutes';
        
        // Refresh data after a short delay
        setTimeout(() => {
            getContractDataDirectly();
        }, 3000);
        
    } catch (error) {
        console.error("Error updating check interval:", error);
        showTransactionStatus('error', '', {
            message: 'Error updating check interval: ' + error.message
        });
    }
}

// Update recheck interval
async function updateRecheckInterval() {
    try {
        if (!contractInstance || !currentAccount) {
            alert('Web3 not initialized or not connected');
            return;
        }
        
        if (currentAccount.toLowerCase() !== ADMIN_WALLET.toLowerCase()) {
            alert('Only admin can update intervals');
            return;
        }
        
        const intervalInput = document.getElementById('recheckIntervalInput');
        const intervalMinutes = parseInt(intervalInput.value);
        
        if (isNaN(intervalMinutes) || intervalMinutes < 5) {
            alert('Please enter a valid interval (minimum 5 minutes)');
            return;
        }
        
        // Convert minutes to seconds for the contract
        const intervalSeconds = intervalMinutes * 60;
        
        // Show pending transaction modal
        showTransactionStatus('pending', '', {
            message: 'Processing update recheck interval transaction. Please wait...'
        });
        
        // Call the set recheck interval function
        const tx = await contractInstance.methods.setRecheckInterval(intervalSeconds).send({
            from: currentAccount,
            gas: 200000,
            gasPrice: web3Instance.utils.toWei('50', 'gwei')
        });
        
        console.log("Update recheck interval transaction:", tx);
        
        // Show success
        showTransactionStatus('success', tx.transactionHash, {
            message: 'Recheck interval updated successfully to ' + intervalMinutes + ' minutes!'
        });
        
        // Update UI
        document.getElementById('recheckIntervalStat').innerText = intervalMinutes + ' minutes';
        
        // Refresh data after a short delay
        setTimeout(() => {
            getContractDataDirectly();
        }, 3000);
        
    } catch (error) {
        console.error("Error updating recheck interval:", error);
        showTransactionStatus('error', '', {
            message: 'Error updating recheck interval: ' + error.message
        });
    }
}

// Set max withdrawal amount
function setMaxWithdrawal() {
    const withdrawInput = document.getElementById("withdrawAmount");
    if (window.withdrawableAmount) {
        withdrawInput.value = window.withdrawableAmount;
    } else {
        alert("Withdrawable amount not yet loaded. Please wait.");
    }
}
// Withdraw funds function
async function withdrawFunds() {
    try {
        // Make sure Web3 is initialized
        if (!web3Instance) {
            console.error("Web3 is not initialized");
            alert("Web3 is not initialized. Please refresh and try again.");
            return;
        }
        
        const accounts = await web3Instance.eth.getAccounts();
        const currentAccount = accounts[0];
        
        console.log("Current account:", currentAccount);
        console.log("Admin wallet:", ADMIN_WALLET);
        
        // Check if admin
        if (currentAccount.toLowerCase() !== ADMIN_WALLET.toLowerCase()) {
            alert("Only the admin wallet can withdraw funds");
            return;
        }

        // Get the amount from input
        const amountInput = document.getElementById("withdrawAmount");
        const amount = amountInput ? amountInput.value : "";
        
        console.log("Amount to withdraw:", amount);
        
        if (!amount || parseFloat(amount) <= 0) {
            alert("Please enter a valid amount");
            return;
        }

        // Check directly with contract what can be withdrawn
        try {
            // Get available revenue
            const revenueFunds = await contractInstance.methods.totalRevenueFunds().call();
            const revenueFundsInMatic = web3Instance.utils.fromWei(revenueFunds, 'ether');
            
            console.log("Available revenue:", revenueFundsInMatic, "MATIC");
            
            if (parseFloat(amount) > parseFloat(revenueFundsInMatic)) {
                alert("Cannot withdraw more than the available revenue funds. Maximum available: " + 
                    parseFloat(revenueFundsInMatic).toFixed(6) + " MATIC");
                return;
            }
            
            // Convert amount to wei
            const amountInWei = web3Instance.utils.toWei(amount, 'ether');
            console.log("Amount in wei:", amountInWei);
            
            // Get current gas price and set to 50 gwei
            const gasPrice = web3Instance.utils.toWei('50', 'gwei');
            console.log("Gas price set to 50 gwei:", gasPrice);
            
            // Make sure contractInstance is initialized
            if (!contractInstance || !contractInstance.methods) {
                console.error("Contract instance not properly initialized");
                alert("Contract connection error. Please refresh and try again.");
                return;
            }
            
            // Show pending transaction modal (keeping this from the first version)
            showTransactionStatus('pending', '', {
                message: 'Processing withdrawal transaction. Please wait...'
            });
            
            // Call the withdraw function with proper error handling
            console.log("Calling withdrawExcessFunds with amount:", amountInWei);
            const tx = await contractInstance.methods.withdrawExcessFunds(amountInWei).send({
                from: currentAccount,
                gas: 300000,
                gasPrice: gasPrice  // Set custom gas price to 50 gwei
            });
            
            console.log("Transaction successful:", tx);
            
            // Show success using the modal function from the first version
            showTransactionStatus('success', tx.transactionHash, {
                message: 'Withdrawal successful! Transaction hash: ' + tx.transactionHash
            });
            
            // Reload data directly
            await getContractDataDirectly();
            
            // Clear input
            amountInput.value = "";
            
        } catch (error) {
            console.error("Error with withdrawal:", error);
            showTransactionStatus('error', '', {
                message: 'Error withdrawing funds: ' + error.message
            });
        }
        
    } catch (error) {
        console.error("Error in withdrawFunds:", error);
        alert("Error withdrawing funds: " + error.message);
    }
}
// Initialize web3 and contract
async function initializeWeb3() {
    if (window.ethereum) {
        try {
            console.log("Initializing Web3 with MetaMask");
            
            // Request account access
            await window.ethereum.request({ method: 'eth_requestAccounts' });
            web3Instance = new Web3(window.ethereum);
            
            // Make sure we have a valid web3 instance
            if (!web3Instance || !web3Instance.eth) {
                throw new Error("Failed to initialize Web3 properly");
            }
            
            console.log("Web3 initialized successfully");
            
            // Get network ID to ensure we're on the right network
            const networkId = await web3Instance.eth.net.getId();
            console.log("Connected to network ID:", networkId);
            
            // Update the connection status
            const connectionStatus = document.getElementById("connectionStatus");
            if (connectionStatus) {
                connectionStatus.className = "alert alert-success d-flex align-items-center";
                connectionStatus.innerHTML = `
                    <i class="fas fa-plug me-2"></i>
                    <div>
                        Connected to blockchain network (ID: ${networkId})
                    </div>
                `;
            }
            
            // Make sure we're using a checksum address
            console.log("Original CONTRACT_ADDRESS:", CONTRACT_ADDRESS);
            const checksumAddress = web3Instance.utils.toChecksumAddress(CONTRACT_ADDRESS);
            console.log("Checksum CONTRACT_ADDRESS:", checksumAddress);
            
            // Create contract instance with full ABI
            contractInstance = new web3Instance.eth.Contract(CONTRACT_ABI, checksumAddress);
            
            if (!contractInstance || !contractInstance.methods) {
                throw new Error("Failed to initialize contract instance");
            }
            
            console.log("Contract instance created successfully");
            console.log("Available methods:", Object.keys(contractInstance.methods).join(", "));
            
            // Get connected accounts
            const accounts = await web3Instance.eth.getAccounts();
            console.log("Connected accounts:", accounts);
            currentAccount = accounts[0];
            
            if (accounts.length === 0) {
                console.warn("No accounts connected");
            }
            
            // Double approach: try direct Web3 calls first, then load from API - like second code
            window.directDataLoaded = false;
            
            // Try both methods for getting data
            await Promise.all([
                getContractDataDirectly(),  // Direct Web3 call
                loadContractFunds(),        // API call
                loadPoliciesFromBackend()   // Load policies
            ]);
            
            // Then load remaining blockchain data (policies count, etc)
            await loadBlockchainData();
            
        } catch (error) {
            console.error("Error initializing Web3:", error);
            
            // Update connection status to show error
            const connectionStatus = document.getElementById("connectionStatus");
            if (connectionStatus) {
                connectionStatus.className = "alert alert-danger d-flex align-items-center";
                connectionStatus.innerHTML = `
                    <i class="fas fa-exclamation-triangle me-2"></i>
                    <div>
                        Error connecting to blockchain: ${error.message}
                    </div>
                `;
            }
            
            // Try to load policies from backend even if Web3 fails
            try {
                await loadPoliciesFromBackend();
            } catch (e) {
                console.error("Failed to load policies after Web3 error:", e);
            }
        }
    } else {
        console.log("No Ethereum browser extension detected");
        
        // Update connection status to show warning
        const connectionStatus = document.getElementById("connectionStatus");
        if (connectionStatus) {
            connectionStatus.className = "alert alert-warning d-flex align-items-center";
            connectionStatus.innerHTML = `
                <i class="fas fa-exclamation-triangle me-2"></i>
                <div>
                    Please install MetaMask to use blockchain features
                </div>
            `;
        }
        
        // Still try to load policies from backend even without Web3
        try {
            await loadPoliciesFromBackend();
        } catch (e) {
            console.error("Failed to load policies:", e);
        }
    }
}
// Initialize on window load
window.onload = function() {
    initializeWeb3();
    
    // Handle sidebar collapse event to adjust content width
    document.addEventListener('DOMContentLoaded', function() {
        const sidebar = document.querySelector('.sidebar');
        const homeContent = document.querySelector('.home-content');
        
        if (sidebar && homeContent) {
            // Check initial state
            if (sidebar.classList.contains('close')) {
                homeContent.style.marginLeft = '78px';
                homeContent.style.width = 'calc(100% - 78px)';
            }
            
            // Listen for class changes on sidebar
            const observer = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    if (mutation.attributeName === 'class') {
                        if (sidebar.classList.contains('close')) {
                            homeContent.style.marginLeft = '78px';
                            homeContent.style.width = 'calc(100% - 78px)';
                        } else {
                            homeContent.style.marginLeft = '260px';
                            homeContent.style.width = 'calc(100% - 260px)';
                        }
                    }
                });
            });
            
            observer.observe(sidebar, { attributes: true });
        }
    });
};
</script>
</body>
</html>